var game;
var images = {};
function main() {
    CanvasRenderingContext2D.prototype.drawString = function (text, x, y, size, font, colour, align) {
        var context = this;
        context.fillStyle = colour.getHexString();
        context.font = size + "px " + font;
        var width = context.measureText(text).width;
        var height = size;
        //TODO: look into CanvasTextAlign and CanvasTextBaseline
        var actualX = x;
        var actualY = y;
        if (align === Align.Bottom
            || align === Align.BottomLeft
            || align === Align.BottomRight)
            actualY = y + height;
        else if (align === Align.Left
            || align === Align.Center
            || align === Align.Right)
            actualY = y + height / 2;
        if (align === Align.Top
            || align === Align.Center
            || align === Align.Bottom)
            actualX = x + width / 2;
        else if (align === Align.TopRight
            || align === Align.Right
            || align === Align.BottomRight)
            actualX = x + width;
        context.fillText(text, actualX, actualY);
    };
    CanvasRenderingContext2D.prototype.measureString = function (text, size, font) {
        var context = this;
        context.font = size + "px " + font;
        return context.measureText(text);
    };
    CanvasRenderingContext2D.prototype.drawRect = function (x, y, w, h, colour, fill) {
        if (fill === void 0) { fill = false; }
        var context = this;
        if (fill) {
            context.fillStyle = colour.getHexString();
            context.fillRect(x, y, w, h);
        }
        else {
            context.strokeStyle = colour.getHexString();
            context.strokeRect(x, y, w, h);
        }
    };
    game = new Game();
    game.init();
    game.startUpdating();
    game.startDrawing();
}
var Game = /** @class */ (function () {
    function Game() {
        var _this = this;
        this.blocksDict = {};
        this.upgradesDict = {};
        this.images = {};
        this.updateInterval = 1000 / 60;
        this.drawInterval = 1000 / 60;
        this.colours = {
            background: new Colour(0, 80, 80),
            textNormal: new Colour(160, 160, 160),
            textGood: new Colour(0, 160, 0),
            textBad: new Colour(160, 0, 0),
            boxNormal: new Colour(160, 160, 160),
            boxGood: new Colour(0, 160, 0),
            boxBad: new Colour(160, 0, 0),
        };
        this.fonts = {
            default: 'Arial'
        };
        this.canvas = document.getElementById('gameCanvas');
        this.context = this.canvas.getContext('2d');
        this.updateWindowSize();
        window.addEventListener('resize', function () { return _this.updateWindowSize(); });
    }
    Game.prototype.init = function () {
        this.setupBlocks();
        this.setupUpgrades();
        this.input = new Input(this.canvas);
        this.points = new Points();
        this.grid = new Grid();
        this.grid.init();
        this.blockTray = new BlockTray();
        this.upgradeTray = new UpgradeTray();
        this.titleBar = new TitleBar();
    };
    Game.prototype.update = function () {
        this.tooltip = null;
        this.input.update();
        this.grid.update();
        this.blockTray.update();
        this.upgradeTray.update();
        this.points.update();
    };
    Game.prototype.draw = function () {
        this.context.clearRect(0, 0, this.width, this.height);
        this.titleBar.draw(this.context);
        this.points.draw(this.context);
        this.grid.draw(this.context);
        this.blockTray.draw(this.context);
        this.upgradeTray.draw(this.context);
        if (this.tooltip != null) {
            this.tooltip.draw(this.context);
        }
    };
    Game.prototype.startUpdating = function () {
        var _this = this;
        setInterval(function () { return _this.update(); }, this.updateInterval);
    };
    Game.prototype.startDrawing = function () {
        var _this = this;
        setInterval(function () { return _this.draw(); }, this.drawInterval);
    };
    Game.prototype.setupBlocks = function () {
        var _this = this;
        this.blocks = [
            new BlockInfo(BlockType.Incrementor, 10, 'Incrementor', 'I', 'Generates {{magnitude}} point{{plural}} per second.', 1, true),
            new BlockInfo(BlockType.Adder, 20, 'Adder', 'A', 'Increases the points generated by adjacent incrementors by {{magnitude}}.', 1),
            new BlockInfo(BlockType.Doubler, 30, 'Doubler', 'D', 'Increases the effectiveness of adjacent Adders by {{magnitude}}x', 2),
            new BlockInfo(BlockType.EdgeCase, 40, 'Edge Case', 'E', 'Increases points per second by {{magnitude}}% for each adjacent grid edge.', 5),
            new BlockInfo(BlockType.VoidIncrementor, 50, 'Void Incrementor', 'V', 'Generates {{magnitude}} point{{plural}} for each adjacent grid edge or empty cell.', 1),
            new BlockInfo(BlockType.Recursor, 60, 'Recursor', 'R', 'Increases adjacent Doubler multipliers by {{magnitude}}% for each adjacent incrementor.', 50),
            new BlockInfo(BlockType.Inheritor, 70, 'Inheritor', 'N', 'Copies the points generated from all adjacent incrementors.', 0),
        ];
        this.blocks.forEach(function (x) { return _this.blocksDict[x.type] = x; });
    };
    Game.prototype.setupUpgrades = function () {
        var _this = this;
        this.upgrades = [
            new UpgradeInfo(Upgrade.GridSize1, 20, 'Bigger grid', 'Increases the size of the grid by 1.', '+', UpgradeEffect.BiggerGrid),
            new UpgradeInfo(Upgrade.GridSize2, 200, 'Even bigger grid', 'Increases the size of the grid by 1.', '+', UpgradeEffect.BiggerGrid, Upgrade.GridSize1),
            new UpgradeInfo(Upgrade.GridSize3, 2000, 'Even even bigger grid', 'Increases the size of the grid by 1.', '+', UpgradeEffect.BiggerGrid, Upgrade.GridSize2),
            new UpgradeInfo(Upgrade.GridSize4, 20000, 'Mega grid', 'Increases the size of the grid by 1.', '+', UpgradeEffect.BiggerGrid, Upgrade.GridSize3),
            new UpgradeInfo(Upgrade.GridSize5, 200000, 'Ultra grid', 'Increases the size of the grid by 1.', '+', UpgradeEffect.BiggerGrid, Upgrade.GridSize4),
            new UpgradeInfo(Upgrade.GridSize6, 2000000, 'Hyper grid', 'Increases the size of the grid by 1.', '+', UpgradeEffect.BiggerGrid, Upgrade.GridSize5),
            new UpgradeInfo(Upgrade.UnlockAdder, 100, 'Unlock Adders', 'Allows the Adder block to be bought and placed.', 'A', UpgradeEffect.UnlockAdder, Upgrade.GridSize1),
            new UpgradeInfo(Upgrade.UnlockDoubler, 1000, 'Unlock Doublers', 'Allows the Doubler block to be bought and placed.', 'D', UpgradeEffect.UnlockDoubler, Upgrade.GridSize2),
            new UpgradeInfo(Upgrade.UnlockEdgeCase, 10000, 'Unlock Edge Cases', 'Allows the Edge Case block to be bought and placed.', 'E', UpgradeEffect.UnlockEdgeCase, Upgrade.GridSize3),
            new UpgradeInfo(Upgrade.UnlockVoidIncrementor, 100000, 'Unlock Void Incrementors', 'Allows the Void Incrementor block to be bought and placed.', 'V', UpgradeEffect.UnlockVoidIncrementor, Upgrade.GridSize4),
            new UpgradeInfo(Upgrade.UnlockRecursor, 1000000, 'Unlock Recursors', 'Allows the Recursor block to be bought and placed.', 'R', UpgradeEffect.UnlockRecursor, Upgrade.GridSize5),
            new UpgradeInfo(Upgrade.UnlockInheritor, 10000000, 'Unlock Inheritors', 'Allows the Inheritor block to be bought and placed.', 'N', UpgradeEffect.UnlockInheritor, Upgrade.GridSize6),
            new UpgradeInfo(Upgrade.DoubleIncrementors1, 100, 'Better Incrementors', 'Doubles the base points generated by Incrementors.', '2', UpgradeEffect.DoubleIncrementors, Upgrade.GridSize1),
            new UpgradeInfo(Upgrade.DoubleIncrementors2, 1000, 'Even better Incrementors', 'Doubles the base points generated by Incrementors.', '2', UpgradeEffect.DoubleIncrementors, Upgrade.DoubleIncrementors1),
            new UpgradeInfo(Upgrade.DoubleIncrementors3, 10000, 'Even even better Incrementors', 'Doubles the base points generated by Incrementors.', '2', UpgradeEffect.DoubleIncrementors, Upgrade.DoubleIncrementors2),
            new UpgradeInfo(Upgrade.DoubleIncrementors4, 100000, 'Mega Incrementors', 'Doubles the base points generated by Incrementors.', '2', UpgradeEffect.DoubleIncrementors, Upgrade.DoubleIncrementors3),
            new UpgradeInfo(Upgrade.DoubleAdders1, 2000, 'Better Adders', 'Doubles the points given to adjacent incrementors.', '2', UpgradeEffect.DoubleAdders, Upgrade.UnlockAdder),
            new UpgradeInfo(Upgrade.DoubleAdders2, 20000, 'Even better Adders', 'Doubles the points given to adjacent incrementors.', '2', UpgradeEffect.DoubleAdders, Upgrade.DoubleAdders1),
            new UpgradeInfo(Upgrade.DoubleAdders3, 200000, 'Even even better Adders', 'Doubles the points given to adjacent incrementors.', '2', UpgradeEffect.DoubleAdders, Upgrade.DoubleAdders2),
            new UpgradeInfo(Upgrade.DoubleAdders4, 2000000, 'Mega Adders', 'Doubles the points given to adjacent incrementors.', '2', UpgradeEffect.DoubleAdders, Upgrade.DoubleAdders3),
            new UpgradeInfo(Upgrade.DoubleVoidIncrementors1, 5000, 'Better Void Incrementors', 'Doubles the base points generated by Void Incrementors.', '2', UpgradeEffect.DoubleVoidIncrementors, Upgrade.UnlockVoidIncrementor),
            new UpgradeInfo(Upgrade.DoubleVoidIncrementors2, 50000, 'Even better Void Incrementors', 'Doubles the base points generated by Void Incrementors.', '2', UpgradeEffect.DoubleVoidIncrementors, Upgrade.DoubleVoidIncrementors1),
            new UpgradeInfo(Upgrade.DoubleVoidIncrementors3, 500000, 'Even even better Void Incrementors', 'Doubles the base points generated by Void Incrementors.', '2', UpgradeEffect.DoubleVoidIncrementors, Upgrade.DoubleVoidIncrementors2),
            new UpgradeInfo(Upgrade.DoubleVoidIncrementors4, 5000000, 'Mega Void Incrementors', 'Doubles the base points generated by Void Incrementors.', '2', UpgradeEffect.DoubleVoidIncrementors, Upgrade.DoubleVoidIncrementors3),
        ].sort(function (x, y) { return x.cost - y.cost; });
        this.upgrades.forEach(function (x) {
            _this.upgradesDict[x.id] = x;
            x.init();
        });
    };
    Game.prototype.getBlockInfo = function (blockType) {
        return this.blocks.filter(function (x) { return x.type === blockType; })[0];
    };
    Game.prototype.getUpgradeInfo = function (upgrade) {
        return this.upgrades.filter(function (x) { return x.id === upgrade; })[0];
    };
    Game.prototype.updateWindowSize = function () {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
    };
    return Game;
}());
var MouseState = /** @class */ (function () {
    function MouseState(x, y, left, right) {
        this.x = x;
        this.y = y;
        this.left = left;
        this.right = right;
    }
    return MouseState;
}());
var Input = /** @class */ (function () {
    function Input(canvas) {
        var _this = this;
        this.previousMouseState = new MouseState(0, 0, false, false);
        this.currentMouseState = new MouseState(0, 0, false, false);
        this.runningMouseState = new MouseState(0, 0, false, false);
        canvas.addEventListener('mousedown', function (event) {
            if (event.button === MouseButton.Left)
                _this.runningMouseState.left = true;
            else if (event.button === MouseButton.Right)
                _this.runningMouseState.right = true;
        });
        canvas.addEventListener('mouseup', function (event) {
            if (event.button === MouseButton.Left)
                _this.runningMouseState.left = false;
            else if (event.button === MouseButton.Right)
                _this.runningMouseState.right = false;
        });
        canvas.addEventListener('mousemove', function (event) {
            var target = event.currentTarget;
            var rect = target.getBoundingClientRect();
            _this.runningMouseState.x = event.clientX - rect.left;
            _this.runningMouseState.y = event.clientY - rect.top;
        });
        canvas.addEventListener('contextmenu', function (event) { return event.preventDefault(); });
    }
    Input.prototype.update = function () {
        this.previousMouseState = this.currentMouseState;
        this.currentMouseState = new MouseState(this.runningMouseState.x, this.runningMouseState.y, this.runningMouseState.left, this.runningMouseState.right);
    };
    Input.prototype.getX = function () {
        return this.currentMouseState.x;
    };
    Input.prototype.getY = function () {
        return this.currentMouseState.y;
    };
    Input.prototype.isUp = function (mouseButton) {
        if (mouseButton === MouseButton.Left)
            return !this.currentMouseState.left;
        if (mouseButton === MouseButton.Right)
            return !this.currentMouseState.right;
        return false;
    };
    Input.prototype.isDown = function (mouseButton) {
        if (mouseButton === MouseButton.Left)
            return this.currentMouseState.left;
        if (mouseButton === MouseButton.Right)
            return this.currentMouseState.right;
        return false;
    };
    Input.prototype.isClicked = function (mouseButton) {
        if (mouseButton === MouseButton.Left)
            return this.currentMouseState.left && !this.previousMouseState.left;
        if (mouseButton === MouseButton.Right)
            return this.currentMouseState.right && !this.previousMouseState.right;
        return false;
    };
    Input.prototype.isReleased = function (mouseButton) {
        if (mouseButton === MouseButton.Left)
            return !this.currentMouseState.left && this.previousMouseState.left;
        if (mouseButton === MouseButton.Right)
            return !this.currentMouseState.right && this.previousMouseState.right;
        return false;
    };
    return Input;
}());
var Grid = /** @class */ (function () {
    function Grid() {
        this.width = 1;
        this.height = 1;
        this.offsetX = 15;
        this.offsetY = 50;
        this.padding = 5;
        this.size = 50;
        this.paddedSize = this.size - this.padding;
        this.paddedOffsetX = this.offsetX + this.padding;
        this.paddedOffsetY = this.offsetY + this.padding;
    }
    Grid.prototype.init = function () {
        this.grid = [];
        for (var x = 0; x < this.width; x++) {
            var arr = [];
            for (var y = 0; y < this.height; y++) {
                arr.push(BlockType.Empty);
            }
            this.grid.push(arr);
        }
    };
    Grid.prototype.update = function () {
        var input = game.input;
        var inputX = input.getX();
        var inputY = input.getY();
        if (input.isClicked(MouseButton.Left) && game.blockTray.canPurchase()) {
            for (var x = 0; x < this.width; x++) {
                for (var y = 0; y < this.height; y++) {
                    if (this.grid[x][y] === BlockType.Empty && pointWithinRectangle(inputX, inputY, this.paddedOffsetX + x * this.size, this.paddedOffsetY + y * this.size, this.paddedSize, this.paddedSize)) {
                        this.grid[x][y] = game.blockTray.purchase();
                        this.updatePointsPerTick();
                    }
                }
            }
        }
        if (input.isClicked(MouseButton.Right)) {
            for (var x = 0; x < this.width; x++) {
                for (var y = 0; y < this.height; y++) {
                    if (this.grid[x][y] !== BlockType.Empty && pointWithinRectangle(inputX, inputY, this.paddedOffsetX + x * this.size, this.paddedOffsetY + y * this.size, this.paddedSize, this.paddedSize)) {
                        this.grid[x][y] = BlockType.Empty;
                        this.updatePointsPerTick();
                    }
                }
            }
        }
    };
    Grid.prototype.draw = function (context) {
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                var rectX = this.paddedOffsetX + x * this.size;
                var rectY = this.paddedOffsetY + y * this.size;
                context.drawRect(rectX, rectY, this.paddedSize, this.paddedSize, game.colours.boxNormal, false);
                var cell = this.grid[x][y];
                if (cell !== BlockType.Empty) {
                    var block = game.blocksDict[cell];
                    context.drawString(block.char, rectX + 10, rectY + 35, 30, game.fonts.default, game.colours.textNormal, Align.Default);
                }
            }
        }
    };
    Grid.prototype.adjustGridSize = function () {
        for (var x = 0; x < this.width; x++) {
            if (this.grid.length > x) {
                var arr = this.grid[x];
                for (var toAdd = this.height - arr.length; toAdd--; toAdd > 0) {
                    arr.push(BlockType.Empty);
                }
                this.grid[x] = arr;
            }
            else {
                var arr = [];
                for (var y = 0; y < this.height; y++) {
                    arr.push(BlockType.Empty);
                }
                this.grid.push(arr);
            }
        }
        this.updatePointsPerTick();
    };
    Grid.prototype.updatePointsPerTick = function () {
        var pointGrid = [];
        var adderGrid = [];
        var incrementorBlock = game.getBlockInfo(BlockType.Incrementor);
        var voidIncrementorBlock = game.getBlockInfo(BlockType.VoidIncrementor);
        for (var x = 0; x < this.width; x++) {
            var arr = [];
            for (var y = 0; y < this.height; y++) {
                var blockType = this.grid[x][y];
                if (blockType === BlockType.Incrementor)
                    arr.push(incrementorBlock.magnitude);
                else if (blockType === BlockType.VoidIncrementor)
                    arr.push(this.getVoidPoints(x, y, voidIncrementorBlock.magnitude));
                else
                    arr.push(0);
            }
            pointGrid.push(arr);
        }
        var adderBlock = game.getBlockInfo(BlockType.Adder);
        for (var x = 0; x < this.width; x++) {
            var arr = [];
            for (var y = 0; y < this.height; y++) {
                arr.push(this.grid[x][y] === BlockType.Adder ? adderBlock.magnitude : 0);
            }
            adderGrid.push(arr);
        }
        var recursorBlock = game.getBlockInfo(BlockType.Recursor);
        var recursorMagnitude = recursorBlock.magnitude / 100;
        var multiplierGrid = createMultidimensionalArray(this.width, this.height, 0);
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.grid[x][y] === BlockType.Recursor)
                    multiplierGrid[x][y] = recursorMagnitude * this.getAdjacentIncrementors(x, y);
            }
        }
        var doublerBlock = game.getBlockInfo(BlockType.Doubler);
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.grid[x][y] === BlockType.Doubler) {
                    var multiplier = this.getMultiplierValue(x, y, multiplierGrid, doublerBlock.magnitude);
                    this.tryMultiplyCoord(x - 1, y, multiplier, adderGrid);
                    this.tryMultiplyCoord(x + 1, y, multiplier, adderGrid);
                    this.tryMultiplyCoord(x, y - 1, multiplier, adderGrid);
                    this.tryMultiplyCoord(x, y + 1, multiplier, adderGrid);
                }
            }
        }
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.grid[x][y] === BlockType.Adder) {
                    this.tryIncrementCoord(x - 1, y, pointGrid, adderGrid[x][y]);
                    this.tryIncrementCoord(x + 1, y, pointGrid, adderGrid[x][y]);
                    this.tryIncrementCoord(x, y - 1, pointGrid, adderGrid[x][y]);
                    this.tryIncrementCoord(x, y + 1, pointGrid, adderGrid[x][y]);
                }
            }
        }
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.grid[x][y] === BlockType.Inheritor) {
                    pointGrid[x][y] = this.getAdjacentPoints(x, y, pointGrid);
                }
            }
        }
        var total = 0;
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                total += pointGrid[x][y];
            }
        }
        var edgeCaseBlock = game.getBlockInfo(BlockType.EdgeCase);
        var edgeCaseMagnitude = (edgeCaseBlock.magnitude / 100) + 1;
        var edgeMult = 1;
        for (var x = 0; x < this.width; x++) {
            for (var y = 0; y < this.height; y++) {
                if (this.grid[x][y] === BlockType.EdgeCase) {
                    edgeMult *= Math.pow(edgeCaseMagnitude, this.getEdgesTouched(x, y));
                }
            }
        }
        total *= edgeMult;
        game.points.pointsPerTick = total;
    };
    Grid.prototype.getBlockTypeOfCoord = function (x, y) {
        return x <= -1 || y <= -1 || x >= this.width || y >= this.height ? BlockType.Empty : this.grid[x][y];
    };
    Grid.prototype.getValueOfCoord = function (x, y, grid) {
        return x <= -1 || y <= -1 || x >= this.width || y >= this.height ? 0 : grid[x][y];
    };
    Grid.prototype.tryIncrementCoord = function (x, y, grid, incrementAmount) {
        var blockType = this.getBlockTypeOfCoord(x, y);
        if (blockType === BlockType.Incrementor
            || blockType === BlockType.VoidIncrementor) {
            grid[x][y] += incrementAmount;
        }
    };
    Grid.prototype.getAdjacentPoints = function (x, y, grid) {
        var points = 0;
        points += this.getValueOfCoord(x - 1, y, grid);
        points += this.getValueOfCoord(x + 1, y, grid);
        points += this.getValueOfCoord(x, y - 1, grid);
        points += this.getValueOfCoord(x, y + 1, grid);
        return points;
    };
    Grid.prototype.tryMultiplyCoord = function (x, y, magnitude, grid) {
        if (this.getBlockTypeOfCoord(x, y) === BlockType.Adder) {
            grid[x][y] *= magnitude;
        }
    };
    Grid.prototype.getEdgesTouched = function (x, y) {
        var edgesTouched = 0;
        if (x === 0)
            edgesTouched++;
        if (y === 0)
            edgesTouched++;
        if (x === this.width - 1)
            edgesTouched++;
        if (y === this.height - 1)
            edgesTouched++;
        return edgesTouched;
    };
    Grid.prototype.getVoidPoints = function (x, y, magnitude) {
        var points = 0;
        if (this.getBlockTypeOfCoord(x - 1, y) === BlockType.Empty)
            points += magnitude;
        if (this.getBlockTypeOfCoord(x + 1, y) === BlockType.Empty)
            points += magnitude;
        if (this.getBlockTypeOfCoord(x, y - 1) === BlockType.Empty)
            points += magnitude;
        if (this.getBlockTypeOfCoord(x, y + 1) === BlockType.Empty)
            points += magnitude;
        return points;
    };
    Grid.prototype.getAdjacentIncrementors = function (x, y) {
        var adjacent = 0;
        var left = this.getBlockTypeOfCoord(x - 1, y);
        var right = this.getBlockTypeOfCoord(x + 1, y);
        var up = this.getBlockTypeOfCoord(x, y - 1);
        var down = this.getBlockTypeOfCoord(x, y + 1);
        if (left === BlockType.Incrementor || left == BlockType.VoidIncrementor)
            adjacent++;
        if (right === BlockType.Incrementor || right == BlockType.VoidIncrementor)
            adjacent++;
        if (up === BlockType.Incrementor || up == BlockType.VoidIncrementor)
            adjacent++;
        if (down === BlockType.Incrementor || down == BlockType.VoidIncrementor)
            adjacent++;
        return adjacent;
    };
    Grid.prototype.getMultiplierValue = function (x, y, grid, magnitude) {
        var totalAdjacent = 1 +
            this.getValueOfCoord(x - 1, y, grid) +
            this.getValueOfCoord(x + 1, y, grid) +
            this.getValueOfCoord(x, y - 1, grid) +
            this.getValueOfCoord(x, y + 1, grid);
        return totalAdjacent * magnitude;
    };
    return Grid;
}());
var Points = /** @class */ (function () {
    function Points() {
        this.points = 10;
        this.pointsPerTick = 0;
        this.updateTime = 1000;
        this.currentTime = 0;
        this.offsetX = 20;
        this.offsetY = 260;
    }
    Points.prototype.update = function () {
        this.currentTime += game.updateInterval;
        if (this.currentTime >= this.updateTime) {
            this.currentTime -= this.updateTime;
            this.points += this.pointsPerTick;
        }
    };
    Points.prototype.draw = function (context) {
        context.drawString('Points', this.offsetX, game.height - this.offsetY - 60, 30, game.fonts.default, game.colours.textNormal, Align.Default);
        context.drawString(this.points.toFixed(), this.offsetX, game.height - this.offsetY - 30, 30, game.fonts.default, game.colours.textNormal, Align.Default);
        context.drawString(this.pointsPerTick.toFixed(1) + '/s', this.offsetX, game.height - this.offsetY, 30, game.fonts.default, game.colours.textNormal, Align.Default);
    };
    return Points;
}());
var BlockInfo = /** @class */ (function () {
    function BlockInfo(type, cost, name, char, description, magnitude, unlocked) {
        if (unlocked === void 0) { unlocked = false; }
        this.type = type;
        this.cost = cost;
        this.name = name;
        this.char = char;
        this.description = description;
        this.magnitude = magnitude;
        this.unlocked = unlocked;
    }
    BlockInfo.prototype.getDynamicDescription = function () {
        var desc = this.description;
        desc = desc.replace('{{magnitude}}', this.magnitude.toFixed());
        desc = desc.replace('{{plural}}', this.magnitude === 1 ? '' : 's');
        return desc;
    };
    return BlockInfo;
}());
var BlockTray = /** @class */ (function () {
    function BlockTray() {
        this.blocks = [];
        this.selected = -1;
        this.offsetX = 20;
        this.offsetY = 140;
    }
    BlockTray.prototype.update = function () {
        var input = game.input;
        var x = input.getX();
        var y = input.getY();
        var visibleBlocks = this.getVisibleBlocks();
        for (var i = 0; i < visibleBlocks.length; i++) {
            if (pointWithinRectangle(x, y, this.offsetX + (50 * i), game.height - this.offsetY - 50, 45, 45)) {
                var block = visibleBlocks[i];
                if (input.isClicked(MouseButton.Left)) {
                    this.selected = this.selected === i ? -1 : i;
                }
                game.tooltip = new Tooltip(block.name, block.getDynamicDescription(), x, y, block.cost);
            }
        }
    };
    BlockTray.prototype.draw = function (context) {
        var visibleBlocks = this.getVisibleBlocks();
        for (var i = 0; i < visibleBlocks.length; i++) {
            var block = visibleBlocks[i];
            var selected = i === this.selected;
            var x = this.offsetX + (50 * i);
            context.drawRect(x, game.height - this.offsetY - 50, 45, 45, selected ? game.colours.boxGood : game.colours.boxNormal, false);
            context.drawString(block.char, x + 10, game.height - this.offsetY - 15, 30, game.fonts.default, selected ? game.colours.textGood : game.colours.textNormal, Align.Default);
        }
        context.drawString('Blocks', this.offsetX, game.height - this.offsetY - 65, 30, game.fonts.default, game.colours.textNormal, Align.Default);
    };
    BlockTray.prototype.canPurchase = function () {
        return this.selected !== -1 && game.points.points >= this.getVisibleBlocks()[this.selected].cost;
    };
    BlockTray.prototype.purchase = function () {
        var block = this.getVisibleBlocks()[this.selected];
        game.points.points -= block.cost;
        return block.type;
    };
    BlockTray.prototype.getVisibleBlocks = function () {
        return game.blocks.filter(function (x) { return x.unlocked; });
    };
    return BlockTray;
}());
var UpgradeInfo = /** @class */ (function () {
    function UpgradeInfo(id, cost, name, description, char, effect, preId) {
        if (preId === void 0) { preId = null; }
        this.id = id;
        this.cost = cost;
        this.name = name;
        this.description = description;
        this.char = char;
        this.effect = effect;
        this.preId = preId;
        this.purchased = false;
        this.pre = null;
    }
    UpgradeInfo.prototype.init = function () {
        if (this.preId != null) {
            this.pre = game.getUpgradeInfo(this.preId);
        }
    };
    UpgradeInfo.prototype.isVisible = function () {
        return !this.purchased && (this.preId == null || game.getUpgradeInfo(this.preId).purchased == true);
    };
    UpgradeInfo.prototype.action = function () {
        if (this.effect === UpgradeEffect.BiggerGrid) {
            game.grid.width += 1;
            game.grid.height += 1;
            game.grid.adjustGridSize();
        }
        else if (this.effect === UpgradeEffect.UnlockAdder) {
            game.getBlockInfo(BlockType.Adder).unlocked = true;
        }
        else if (this.effect === UpgradeEffect.UnlockDoubler) {
            game.getBlockInfo(BlockType.Doubler).unlocked = true;
        }
        else if (this.effect === UpgradeEffect.UnlockEdgeCase) {
            game.getBlockInfo(BlockType.EdgeCase).unlocked = true;
        }
        else if (this.effect === UpgradeEffect.UnlockVoidIncrementor) {
            game.getBlockInfo(BlockType.VoidIncrementor).unlocked = true;
        }
        else if (this.effect === UpgradeEffect.UnlockRecursor) {
            game.getBlockInfo(BlockType.Recursor).unlocked = true;
        }
        else if (this.effect === UpgradeEffect.UnlockInheritor) {
            game.getBlockInfo(BlockType.Inheritor).unlocked = true;
        }
        else if (this.effect === UpgradeEffect.DoubleIncrementors) {
            game.getBlockInfo(BlockType.Incrementor).magnitude *= 2;
            game.grid.updatePointsPerTick();
        }
        else if (this.effect === UpgradeEffect.DoubleAdders) {
            game.getBlockInfo(BlockType.Adder).magnitude *= 2;
            game.grid.updatePointsPerTick();
        }
        else if (this.effect === UpgradeEffect.DoubleVoidIncrementors) {
            game.getBlockInfo(BlockType.VoidIncrementor).magnitude *= 2;
            game.grid.updatePointsPerTick();
        }
    };
    UpgradeInfo.prototype.purchase = function () {
        game.points.points -= this.cost;
        this.action();
        this.purchased = true;
    };
    return UpgradeInfo;
}());
var UpgradeTray = /** @class */ (function () {
    function UpgradeTray() {
        this.offsetX = 20;
        this.offsetY = 20;
    }
    UpgradeTray.prototype.update = function () {
        var input = game.input;
        var x = input.getX();
        var y = input.getY();
        var visibleUpgrades = this.getVisibleUpgrades();
        for (var i = 0; i < visibleUpgrades.length; i++) {
            if (pointWithinRectangle(x, y, this.offsetX + (50 * i), game.height - this.offsetY - 45, 45, 45)) {
                var upgrade = visibleUpgrades[i];
                if (input.isClicked(MouseButton.Left) && upgrade.cost <= game.points.points) {
                    upgrade.purchase();
                }
                game.tooltip = new Tooltip(upgrade.name, upgrade.description, x, y, upgrade.cost);
            }
        }
    };
    UpgradeTray.prototype.draw = function (context) {
        var visibleUpgrades = this.getVisibleUpgrades();
        for (var i = 0; i < visibleUpgrades.length; i++) {
            var upgrade = visibleUpgrades[i];
            var x = this.offsetX + (50 * i);
            context.drawRect(x, game.height - this.offsetY - 45, 45, 45, game.colours.boxNormal, false);
            context.drawString(upgrade.char, x + 10, game.height - this.offsetY - 10, 30, game.fonts.default, game.colours.textNormal, Align.Default);
        }
        context.drawString('Upgrades', this.offsetX, game.height - this.offsetY - 60, 30, game.fonts.default, game.colours.textNormal, Align.Default);
    };
    UpgradeTray.prototype.getVisibleUpgrades = function () {
        return game.upgrades.filter(function (x) { return x.isVisible(); });
    };
    return UpgradeTray;
}());
var Tooltip = /** @class */ (function () {
    function Tooltip(title, text, x, y, cost) {
        if (cost === void 0) { cost = null; }
        this.title = title;
        this.text = text;
        this.x = x;
        this.y = y;
        this.cost = cost;
    }
    Tooltip.prototype.draw = function (context) {
        var height = this.getHeight();
        var top = this.getTop();
        var width = this.getWidth(context);
        context.drawRect(this.x, top, width, height, game.colours.background, true);
        context.drawRect(this.x, top, width, height, game.colours.boxNormal, false);
        context.drawString(this.title, this.x + 5, top + 30, 30, game.fonts.default, game.colours.textNormal, Align.Default);
        context.drawString(this.text, this.x + 5, top + 55, 22, game.fonts.default, game.colours.textNormal, Align.Default);
        if (this.cost != null) {
            context.drawString(this.getCostPrefix(), this.x + 5, top + 80, 22, game.fonts.default, game.colours.textNormal, Align.Default);
            context.drawString(this.cost.toString(), this.x + 5 + this.getCostPrefixWidth(context), top + 80, 22, game.fonts.default, this.cost <= game.points.points ? game.colours.textGood : game.colours.textBad, Align.Default);
        }
    };
    Tooltip.prototype.getHeight = function () {
        return this.cost == null ? 60 : 90;
    };
    Tooltip.prototype.getTop = function () {
        return this.y - this.getHeight();
    };
    Tooltip.prototype.getCostPrefix = function () {
        return 'Cost: ';
    };
    Tooltip.prototype.getCostPrefixWidth = function (context) {
        return context.measureText(this.getCostPrefix()).width;
    };
    Tooltip.prototype.getWidth = function (context) {
        var titleWidth = context.measureString(this.title, 30, game.fonts.default).width;
        var textWidth = context.measureString(this.text, 22, game.fonts.default).width;
        if (this.cost == null) {
            return Math.max(titleWidth, textWidth) + 10;
        }
        var costWidth = context.measureString(this.getCostPrefix() + this.cost.toString(), 22, game.fonts.default).width;
        return Math.max(titleWidth, textWidth, costWidth) + 10;
    };
    return Tooltip;
}());
var TitleBar = /** @class */ (function () {
    function TitleBar() {
    }
    TitleBar.prototype.draw = function (context) {
        context.drawString('Blockremental', 20, 20, 30, game.fonts.default, game.colours.textNormal, Align.Left);
    };
    return TitleBar;
}());
var Colour = /** @class */ (function () {
    function Colour(r, g, b) {
        this.r = this.boundValue(r);
        this.g = this.boundValue(g);
        this.b = this.boundValue(b);
        this.setHexString();
    }
    Colour.prototype.getR = function () { return this.r; };
    Colour.prototype.getG = function () { return this.g; };
    Colour.prototype.getB = function () { return this.b; };
    Colour.prototype.getHexString = function () { return this.hexString; };
    Colour.prototype.setHexString = function () {
        var rHex = this.r.toString(16);
        var gHex = this.g.toString(16);
        var bHex = this.b.toString(16);
        this.hexString = '#';
        if (rHex.length === 1)
            this.hexString += '0';
        this.hexString += rHex;
        if (gHex.length === 1)
            this.hexString += '0';
        this.hexString += gHex;
        if (bHex.length === 1)
            this.hexString += '0';
        this.hexString += bHex;
    };
    Colour.prototype.boundValue = function (value) {
        if (value < 0)
            return 0;
        if (value > 255)
            return 255;
        return value;
    };
    return Colour;
}());
function pointWithinRectangle(px, py, rx, ry, rw, rh) {
    return px >= rx
        && px <= rx + rw
        && py >= ry
        && py <= ry + rh;
}
function createMultidimensionalArray(width, height, defaultValue) {
    var multiArray = [];
    for (var x = 0; x < width; x++) {
        var array = [];
        for (var y = 0; y < height; y++) {
            array.push(defaultValue);
        }
        multiArray.push(array);
    }
    return multiArray;
}
var BlockType;
(function (BlockType) {
    BlockType[BlockType["Empty"] = 0] = "Empty";
    BlockType[BlockType["Incrementor"] = 1] = "Incrementor";
    BlockType[BlockType["Adder"] = 2] = "Adder";
    BlockType[BlockType["Doubler"] = 3] = "Doubler";
    BlockType[BlockType["EdgeCase"] = 4] = "EdgeCase";
    BlockType[BlockType["VoidIncrementor"] = 5] = "VoidIncrementor";
    BlockType[BlockType["Recursor"] = 6] = "Recursor";
    BlockType[BlockType["Inheritor"] = 7] = "Inheritor";
})(BlockType || (BlockType = {}));
var Upgrade;
(function (Upgrade) {
    Upgrade[Upgrade["GridSize1"] = 1] = "GridSize1";
    Upgrade[Upgrade["GridSize2"] = 2] = "GridSize2";
    Upgrade[Upgrade["GridSize3"] = 3] = "GridSize3";
    Upgrade[Upgrade["GridSize4"] = 4] = "GridSize4";
    Upgrade[Upgrade["GridSize5"] = 5] = "GridSize5";
    Upgrade[Upgrade["GridSize6"] = 6] = "GridSize6";
    Upgrade[Upgrade["GridSize7"] = 7] = "GridSize7";
    Upgrade[Upgrade["GridSize8"] = 8] = "GridSize8";
    Upgrade[Upgrade["GridSize9"] = 9] = "GridSize9";
    Upgrade[Upgrade["UnlockAdder"] = 101] = "UnlockAdder";
    Upgrade[Upgrade["UnlockDoubler"] = 102] = "UnlockDoubler";
    Upgrade[Upgrade["UnlockEdgeCase"] = 103] = "UnlockEdgeCase";
    Upgrade[Upgrade["UnlockVoidIncrementor"] = 104] = "UnlockVoidIncrementor";
    Upgrade[Upgrade["UnlockRecursor"] = 105] = "UnlockRecursor";
    Upgrade[Upgrade["UnlockInheritor"] = 106] = "UnlockInheritor";
    Upgrade[Upgrade["DoubleIncrementors1"] = 201] = "DoubleIncrementors1";
    Upgrade[Upgrade["DoubleIncrementors2"] = 202] = "DoubleIncrementors2";
    Upgrade[Upgrade["DoubleIncrementors3"] = 203] = "DoubleIncrementors3";
    Upgrade[Upgrade["DoubleIncrementors4"] = 204] = "DoubleIncrementors4";
    Upgrade[Upgrade["DoubleAdders1"] = 301] = "DoubleAdders1";
    Upgrade[Upgrade["DoubleAdders2"] = 302] = "DoubleAdders2";
    Upgrade[Upgrade["DoubleAdders3"] = 303] = "DoubleAdders3";
    Upgrade[Upgrade["DoubleAdders4"] = 304] = "DoubleAdders4";
    Upgrade[Upgrade["DoubleVoidIncrementors1"] = 401] = "DoubleVoidIncrementors1";
    Upgrade[Upgrade["DoubleVoidIncrementors2"] = 402] = "DoubleVoidIncrementors2";
    Upgrade[Upgrade["DoubleVoidIncrementors3"] = 403] = "DoubleVoidIncrementors3";
    Upgrade[Upgrade["DoubleVoidIncrementors4"] = 404] = "DoubleVoidIncrementors4";
})(Upgrade || (Upgrade = {}));
var UpgradeEffect;
(function (UpgradeEffect) {
    UpgradeEffect[UpgradeEffect["BiggerGrid"] = 1] = "BiggerGrid";
    UpgradeEffect[UpgradeEffect["UnlockAdder"] = 101] = "UnlockAdder";
    UpgradeEffect[UpgradeEffect["UnlockDoubler"] = 102] = "UnlockDoubler";
    UpgradeEffect[UpgradeEffect["UnlockEdgeCase"] = 103] = "UnlockEdgeCase";
    UpgradeEffect[UpgradeEffect["UnlockVoidIncrementor"] = 104] = "UnlockVoidIncrementor";
    UpgradeEffect[UpgradeEffect["UnlockRecursor"] = 105] = "UnlockRecursor";
    UpgradeEffect[UpgradeEffect["UnlockInheritor"] = 106] = "UnlockInheritor";
    UpgradeEffect[UpgradeEffect["DoubleIncrementors"] = 201] = "DoubleIncrementors";
    UpgradeEffect[UpgradeEffect["DoubleAdders"] = 202] = "DoubleAdders";
    UpgradeEffect[UpgradeEffect["DoubleVoidIncrementors"] = 205] = "DoubleVoidIncrementors";
})(UpgradeEffect || (UpgradeEffect = {}));
var MouseButton;
(function (MouseButton) {
    MouseButton[MouseButton["Left"] = 0] = "Left";
    MouseButton[MouseButton["Middle"] = 1] = "Middle";
    MouseButton[MouseButton["Right"] = 2] = "Right";
    MouseButton[MouseButton["Back"] = 3] = "Back";
    MouseButton[MouseButton["Forward"] = 4] = "Forward";
})(MouseButton || (MouseButton = {}));
var Align;
(function (Align) {
    Align[Align["Default"] = 0] = "Default";
    Align[Align["TopLeft"] = 1] = "TopLeft";
    Align[Align["Top"] = 2] = "Top";
    Align[Align["TopRight"] = 3] = "TopRight";
    Align[Align["Left"] = 4] = "Left";
    Align[Align["Center"] = 5] = "Center";
    Align[Align["Right"] = 6] = "Right";
    Align[Align["BottomLeft"] = 7] = "BottomLeft";
    Align[Align["Bottom"] = 8] = "Bottom";
    Align[Align["BottomRight"] = 9] = "BottomRight";
})(Align || (Align = {}));
var ImageNames;
(function (ImageNames) {
    ImageNames["Test"] = "test";
})(ImageNames || (ImageNames = {}));
function setupImages() {
    var imageDiv = document.getElementById('images');
    for (var imageName in ImageNames) {
        var image = new Image();
        image.src = 'images/' + ImageNames[imageName] + '.png';
        imageDiv.append(image);
        images[ImageNames[imageName]] = image;
    }
}
setupImages();
window.onload = main;
//# sourceMappingURL=main.js.map